"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlocksAtHeightRequestToV2 = exports.accountTransactionSignatureToV2 = exports.blockFinalizationSummary = exports.blockSpecialEvent = exports.peerInfo = exports.nodeInfo = exports.trNodeInfo_Node = exports.nextUpdateSequenceNumbers = exports.electionInfo = exports.branch = exports.delegatorInfo = exports.blockInfo = exports.blocksAtHeightResponse = exports.arInfo = exports.ipInfo = exports.instanceStateKVPair = exports.commonBlockInfo = exports.instanceInfo = exports.invokeInstanceResponse = exports.blockItemStatus = exports.blockItemSummary = exports.pendingUpdate = exports.consensusInfo = exports.tokenomicsInfo = exports.passiveDelegationInfo = exports.bakerPoolInfo = exports.blockChainParameters = exports.cryptographicParameters = exports.nextAccountSequenceNumber = exports.accountInfo = exports.unwrapToBase58 = exports.unwrapValToHex = void 0;
const v1 = __importStar(require("./types"));
const v2 = __importStar(require("../grpc/v2/concordium/types"));
const util_1 = require("./util");
const buffer_1 = require("buffer/");
const bs58check_1 = __importDefault(require("bs58check"));
const accountAddress_1 = require("./types/accountAddress");
const moduleReference_1 = require("./types/moduleReference");
const ccdAmount_1 = require("./types/ccdAmount");
function unwrapToHex(bytes) {
    return buffer_1.Buffer.from((0, util_1.unwrap)(bytes)).toString('hex');
}
function unwrapValToHex(x) {
    return unwrapToHex((0, util_1.unwrap)(x).value);
}
exports.unwrapValToHex = unwrapValToHex;
function unwrapToBase58(address) {
    return bs58check_1.default.encode(buffer_1.Buffer.concat([buffer_1.Buffer.of(1), (0, util_1.unwrap)(address?.value)]));
}
exports.unwrapToBase58 = unwrapToBase58;
function trRelease(release) {
    return {
        timestamp: trTimestamp(release.timestamp),
        amount: (0, util_1.unwrap)(release.amount?.value),
        transactions: release.transactions.map(unwrapValToHex),
    };
}
function trNewRelease(release) {
    return {
        timestamp: trTimestamp(release.timestamp),
        amount: (0, util_1.unwrap)(release.amount?.value),
    };
}
function trDate(ym) {
    return String(ym.year) + String(ym.month).padStart(2, '0');
}
function trAttKey(attributeKey) {
    return v1.AttributesKeys[attributeKey];
}
function trCommits(cmm) {
    return {
        cmmPrf: unwrapValToHex(cmm.prf),
        cmmCredCounter: unwrapValToHex(cmm.credCounter),
        cmmIdCredSecSharingCoeff: cmm.idCredSecSharingCoeff.map(unwrapValToHex),
        cmmAttributes: (0, util_1.mapRecord)(cmm.attributes, unwrapValToHex, trAttKey),
        cmmMaxAccounts: unwrapValToHex(cmm.maxAccounts),
    };
}
function trVerifyKey(verifyKey) {
    if (verifyKey.key.oneofKind === 'ed25519Key') {
        return {
            schemeId: 'Ed25519',
            verifyKey: unwrapToHex(verifyKey.key.ed25519Key),
        };
    }
    else {
        throw Error('AccountVerifyKey was expected to be of type "ed25519Key", but found' +
            verifyKey.key.oneofKind);
    }
}
function trCredKeys(credKeys) {
    return {
        threshold: (0, util_1.unwrap)(credKeys.threshold?.value),
        keys: (0, util_1.mapRecord)(credKeys.keys, trVerifyKey),
    };
}
function trChainArData(chainArData) {
    return {
        encIdCredPubShare: unwrapToHex(chainArData.encIdCredPubShare),
    };
}
function trCommissionRates(rates) {
    return {
        transactionCommission: trAmountFraction(rates?.transaction),
        bakingCommission: trAmountFraction(rates?.baking),
        finalizationCommission: trAmountFraction(rates?.finalization),
    };
}
function trCred(cred) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const crd = cred.credentialValues;
    if (crd === undefined) {
        throw Error('CredentialValues were undefined.');
    }
    const isNormal = crd.oneofKind === 'normal';
    const credVals = isNormal ? crd.normal : crd.initial;
    const policy = {
        validTo: trDate((0, util_1.unwrap)(credVals.policy?.validTo)),
        createdAt: trDate((0, util_1.unwrap)(credVals.policy?.createdAt)),
        revealedAttributes: (0, util_1.mapRecord)(credVals.policy?.attributes, unwrapToHex, trAttKey),
    };
    const commonValues = {
        ipIdentity: (0, util_1.unwrap)(credVals.ipId?.value),
        credentialPublicKeys: trCredKeys((0, util_1.unwrap)(credVals.keys)),
        policy: policy,
    };
    let value;
    if (isNormal) {
        const deploymentValues = {
            ...commonValues,
            credId: unwrapValToHex(credVals.credId),
            revocationThreshold: (0, util_1.unwrap)(credVals.arThreshold?.value),
            arData: (0, util_1.mapRecord)(credVals.arData, trChainArData, String),
            commitments: trCommits((0, util_1.unwrap)(credVals.commitments)),
        };
        value = {
            type: 'normal',
            contents: deploymentValues,
        };
    }
    else {
        const deploymentValues = {
            ...commonValues,
            regId: unwrapValToHex(credVals.credId),
        };
        value = {
            type: 'initial',
            contents: deploymentValues,
        };
    }
    return {
        v: 0,
        value,
    };
}
function trDelegatorTarget(target) {
    if (target.target.oneofKind === 'passive') {
        return {
            delegateType: v1.DelegationTargetType.PassiveDelegation,
        };
    }
    else if (target.target.oneofKind === 'baker') {
        return {
            delegateType: v1.DelegationTargetType.Baker,
            bakerId: target.target.baker.value,
        };
    }
    else {
        throw Error('DelegatorTarget expected to be of type "passive" or "baker", but found ' +
            target.target.oneofKind);
    }
}
function trTimestamp(timestamp) {
    return new Date(Number((0, util_1.unwrap)(timestamp?.value)));
}
function trPendingChange(pendingChange) {
    const change = (0, util_1.unwrap)(pendingChange?.change);
    if (change.oneofKind === 'reduce') {
        return {
            newStake: (0, util_1.unwrap)(change.reduce.newStake?.value),
            effectiveTime: trTimestamp(change.reduce.effectiveTime),
            change: v1.StakePendingChangeType.ReduceStake,
        };
    }
    else if (change.oneofKind === 'remove') {
        return {
            effectiveTime: trTimestamp(change.remove),
            change: v1.StakePendingChangeType.RemoveStakeV1,
        };
    }
    else {
        throw Error('PendingChange expected to be of type "reduce" or "remove", but found ' +
            change.oneofKind);
    }
}
function trDelegator(deleg) {
    return {
        restakeEarnings: deleg.restakeEarnings,
        stakedAmount: (0, util_1.unwrap)(deleg.stakedAmount?.value),
        delegationTarget: trDelegatorTarget((0, util_1.unwrap)(deleg.target)),
        // Set the following value if deleg.pendingChange is set to true
        ...(deleg.pendingChange && {
            pendingChange: trPendingChange(deleg.pendingChange),
        }),
    };
}
function trAmountFraction(amount) {
    return (0, util_1.unwrap)(amount?.partsPerHundredThousand) / 100000;
}
function trOpenStatus(openStatus) {
    switch ((0, util_1.unwrap)(openStatus)) {
        case v2.OpenStatus.OPEN_FOR_ALL:
            return v1.OpenStatusText.OpenForAll;
        case v2.OpenStatus.CLOSED_FOR_NEW:
            return v1.OpenStatusText.ClosedForNew;
        case v2.OpenStatus.CLOSED_FOR_ALL:
            return v1.OpenStatusText.ClosedForAll;
    }
}
function trBaker(baker) {
    const bakerInfo = baker.bakerInfo;
    const bakerPoolInfo = {
        openStatus: trOpenStatus(baker.poolInfo?.openStatus),
        metadataUrl: (0, util_1.unwrap)(baker.poolInfo?.url),
        commissionRates: trCommissionRates(baker.poolInfo?.commissionRates),
    };
    return {
        restakeEarnings: baker.restakeEarnings,
        bakerId: (0, util_1.unwrap)(baker.bakerInfo?.bakerId?.value),
        bakerAggregationVerifyKey: unwrapValToHex(bakerInfo?.aggregationKey),
        bakerElectionVerifyKey: unwrapValToHex(baker.bakerInfo?.electionKey),
        bakerSignatureVerifyKey: unwrapValToHex(bakerInfo?.signatureKey),
        bakerPoolInfo: bakerPoolInfo,
        stakedAmount: (0, util_1.unwrap)(baker.stakedAmount?.value),
        // Set the following value if baker.pendingChange is set to true
        ...(baker.pendingChange && {
            pendingChange: trPendingChange(baker.pendingChange),
        }),
    };
}
function translateChainParametersCommon(params) {
    return {
        electionDifficulty: trAmountFraction(params.electionDifficulty?.value),
        euroPerEnergy: (0, util_1.unwrap)(params.euroPerEnergy?.value),
        microGTUPerEuro: (0, util_1.unwrap)(params.microCcdPerEuro?.value),
        accountCreationLimit: (0, util_1.unwrap)(params.accountCreationLimit?.value),
        foundationAccount: unwrapToBase58(params.foundationAccount),
    };
}
function translateCommissionRange(range) {
    return {
        min: trAmountFraction(range?.min),
        max: trAmountFraction(range?.max),
    };
}
function translateRewardParametersCommon(params) {
    const feeDistribution = params.transactionFeeDistribution;
    const gasRewards = params.gasRewards;
    return {
        transactionFeeDistribution: {
            baker: trAmountFraction(feeDistribution?.baker),
            gasAccount: trAmountFraction(feeDistribution?.gasAccount),
        },
        gASRewards: {
            baker: trAmountFraction(gasRewards?.baker),
            finalizationProof: trAmountFraction(gasRewards?.finalizationProof),
            accountCreation: trAmountFraction(gasRewards?.accountCreation),
            chainUpdate: trAmountFraction(gasRewards?.chainUpdate),
        },
    };
}
function transPoolPendingChange(change) {
    switch (change?.change?.oneofKind) {
        case 'reduce': {
            return {
                pendingChangeType: v1.BakerPoolPendingChangeType.ReduceBakerCapital,
                // TODO ensure units are aligned
                effectiveTime: trTimestamp(change.change.reduce.effectiveTime),
                bakerEquityCapital: (0, util_1.unwrap)(change.change.reduce.reducedEquityCapital?.value),
            };
        }
        case 'remove': {
            return {
                pendingChangeType: v1.BakerPoolPendingChangeType.RemovePool,
                effectiveTime: trTimestamp(change.change.remove.effectiveTime),
            };
        }
        default:
            return {
                pendingChangeType: v1.BakerPoolPendingChangeType.NoChange,
            };
    }
}
function transPoolInfo(info) {
    return {
        openStatus: trOpenStatus(info.openStatus),
        metadataUrl: info.url,
        commissionRates: trCommissionRates(info.commissionRates),
    };
}
function transPaydayStatus(status) {
    if (!status) {
        return null;
    }
    return {
        blocksBaked: status.blocksBaked,
        finalizationLive: status.finalizationLive,
        transactionFeesEarned: (0, util_1.unwrap)(status.transactionFeesEarned?.value),
        effectiveStake: (0, util_1.unwrap)(status.effectiveStake?.value),
        lotteryPower: status.lotteryPower,
        bakerEquityCapital: (0, util_1.unwrap)(status.bakerEquityCapital?.value),
        delegatedCapital: (0, util_1.unwrap)(status.delegatedCapital?.value),
    };
}
function accountInfo(acc) {
    const aggAmount = acc.encryptedBalance?.aggregatedAmount?.value;
    const numAggregated = acc.encryptedBalance?.numAggregated;
    const encryptedAmount = {
        selfAmount: unwrapValToHex(acc.encryptedBalance?.selfAmount),
        startIndex: (0, util_1.unwrap)(acc.encryptedBalance?.startIndex),
        incomingAmounts: (0, util_1.unwrap)(acc.encryptedBalance?.incomingAmounts).map(unwrapValToHex),
        // Set the following values if they are not undefined
        ...(numAggregated && { numAggregated: numAggregated }),
        ...(aggAmount && { aggregatedAmount: unwrapToHex(aggAmount) }),
    };
    const releaseSchedule = {
        total: (0, util_1.unwrap)(acc.schedule?.total?.value),
        schedule: (0, util_1.unwrap)(acc.schedule?.schedules).map(trRelease),
    };
    const accInfoCommon = {
        accountAddress: unwrapToBase58(acc.address),
        accountNonce: (0, util_1.unwrap)(acc.sequenceNumber?.value),
        accountAmount: (0, util_1.unwrap)(acc.amount?.value),
        accountIndex: (0, util_1.unwrap)(acc.index?.value),
        accountThreshold: (0, util_1.unwrap)(acc.threshold?.value),
        accountEncryptionKey: unwrapValToHex(acc.encryptionKey),
        accountEncryptedAmount: encryptedAmount,
        accountReleaseSchedule: releaseSchedule,
        accountCredentials: (0, util_1.mapRecord)(acc.creds, trCred),
    };
    if (acc.stake?.stakingInfo.oneofKind === 'delegator') {
        return {
            ...accInfoCommon,
            accountDelegation: trDelegator(acc.stake.stakingInfo.delegator),
        };
    }
    else if (acc.stake?.stakingInfo.oneofKind === 'baker') {
        return {
            ...accInfoCommon,
            accountBaker: trBaker(acc.stake.stakingInfo.baker),
        };
    }
    else {
        return accInfoCommon;
    }
}
exports.accountInfo = accountInfo;
function nextAccountSequenceNumber(nasn) {
    return {
        nonce: (0, util_1.unwrap)(nasn.sequenceNumber?.value),
        allFinal: nasn.allFinal,
    };
}
exports.nextAccountSequenceNumber = nextAccountSequenceNumber;
function cryptographicParameters(cp) {
    return {
        onChainCommitmentKey: unwrapToHex(cp.onChainCommitmentKey),
        bulletproofGenerators: unwrapToHex(cp.bulletproofGenerators),
        genesisString: cp.genesisString,
    };
}
exports.cryptographicParameters = cryptographicParameters;
function blockChainParameters(params) {
    switch (params.parameters.oneofKind) {
        case 'v1': {
            const common = translateChainParametersCommon(params.parameters.v1);
            const v1 = params.parameters.v1;
            const commonRewardParameters = translateRewardParametersCommon(v1);
            return {
                ...common,
                rewardPeriodLength: (0, util_1.unwrap)(v1.timeParameters?.rewardPeriodLength?.value?.value),
                mintPerPayday: trMintRate(v1.timeParameters?.mintPerPayday),
                delegatorCooldown: (0, util_1.unwrap)(v1.cooldownParameters?.delegatorCooldown?.value),
                poolOwnerCooldown: (0, util_1.unwrap)(v1.cooldownParameters?.poolOwnerCooldown?.value),
                passiveFinalizationCommission: trAmountFraction(v1.poolParameters?.passiveFinalizationCommission),
                passiveBakingCommission: trAmountFraction(v1.poolParameters?.passiveBakingCommission),
                passiveTransactionCommission: trAmountFraction(v1.poolParameters?.passiveTransactionCommission),
                finalizationCommissionRange: translateCommissionRange(v1.poolParameters?.commissionBounds?.finalization),
                bakingCommissionRange: translateCommissionRange(v1.poolParameters?.commissionBounds?.baking),
                transactionCommissionRange: translateCommissionRange(v1.poolParameters?.commissionBounds?.transaction),
                minimumEquityCapital: (0, util_1.unwrap)(v1.poolParameters?.minimumEquityCapital?.value),
                capitalBound: trAmountFraction(v1.poolParameters?.capitalBound?.value),
                leverageBound: (0, util_1.unwrap)(v1.poolParameters?.leverageBound?.value),
                rewardParameters: {
                    ...commonRewardParameters,
                    mintDistribution: {
                        bakingReward: trAmountFraction(v1.mintDistribution?.bakingReward),
                        finalizationReward: trAmountFraction(v1.mintDistribution?.finalizationReward),
                    },
                },
            };
        }
        case 'v0': {
            const common = translateChainParametersCommon(params.parameters.v0);
            const v0 = params.parameters.v0;
            const commonRewardParameters = translateRewardParametersCommon(v0);
            return {
                ...common,
                bakerCooldownEpochs: (0, util_1.unwrap)(v0.bakerCooldownEpochs?.value),
                minimumThresholdForBaking: (0, util_1.unwrap)(v0.minimumThresholdForBaking?.value),
                rewardParameters: {
                    ...commonRewardParameters,
                    mintDistribution: {
                        bakingReward: trAmountFraction(v0.mintDistribution?.bakingReward),
                        finalizationReward: trAmountFraction(v0.mintDistribution?.finalizationReward),
                        mintPerSlot: trMintRate(v0.mintDistribution?.mintPerSlot),
                    },
                },
            };
        }
        default:
            throw new Error('Missing chain parameters');
    }
}
exports.blockChainParameters = blockChainParameters;
function bakerPoolInfo(info) {
    return {
        poolType: v1.PoolStatusType.BakerPool,
        bakerId: (0, util_1.unwrap)(info.baker?.value),
        bakerAddress: unwrapToBase58(info.address),
        bakerEquityCapital: (0, util_1.unwrap)(info.equityCapital?.value),
        delegatedCapital: (0, util_1.unwrap)(info.delegatedCapital?.value),
        delegatedCapitalCap: (0, util_1.unwrap)(info.delegatedCapitalCap?.value),
        poolInfo: transPoolInfo((0, util_1.unwrap)(info?.poolInfo)),
        bakerStakePendingChange: transPoolPendingChange(info.equityPendingChange),
        currentPaydayStatus: transPaydayStatus(info.currentPaydayInfo),
        allPoolTotalCapital: (0, util_1.unwrap)(info.allPoolTotalCapital?.value),
    };
}
exports.bakerPoolInfo = bakerPoolInfo;
function passiveDelegationInfo(info) {
    return {
        poolType: v1.PoolStatusType.PassiveDelegation,
        delegatedCapital: (0, util_1.unwrap)(info.delegatedCapital?.value),
        commissionRates: trCommissionRates(info.commissionRates),
        currentPaydayTransactionFeesEarned: (0, util_1.unwrap)(info.currentPaydayTransactionFeesEarned?.value),
        currentPaydayDelegatedCapital: (0, util_1.unwrap)(info.currentPaydayDelegatedCapital?.value),
        allPoolTotalCapital: (0, util_1.unwrap)(info.allPoolTotalCapital?.value),
    };
}
exports.passiveDelegationInfo = passiveDelegationInfo;
function tokenomicsInfo(info) {
    switch (info.tokenomics.oneofKind) {
        case 'v0': {
            const v0 = info.tokenomics.v0;
            return {
                protocolVersion: BigInt(v0.protocolVersion),
                totalAmount: (0, util_1.unwrap)(v0.totalAmount?.value),
                totalEncryptedAmount: (0, util_1.unwrap)(v0.totalEncryptedAmount?.value),
                bakingRewardAccount: (0, util_1.unwrap)(v0.bakingRewardAccount?.value),
                finalizationRewardAccount: (0, util_1.unwrap)(v0.finalizationRewardAccount?.value),
                gasAccount: (0, util_1.unwrap)(v0.gasAccount?.value),
            };
        }
        case 'v1': {
            const v1 = info.tokenomics.v1;
            return {
                protocolVersion: BigInt(v1.protocolVersion),
                totalAmount: (0, util_1.unwrap)(v1.totalAmount?.value),
                totalEncryptedAmount: (0, util_1.unwrap)(v1.totalEncryptedAmount?.value),
                bakingRewardAccount: (0, util_1.unwrap)(v1.bakingRewardAccount?.value),
                finalizationRewardAccount: (0, util_1.unwrap)(v1.finalizationRewardAccount?.value),
                gasAccount: (0, util_1.unwrap)(v1.gasAccount?.value),
                foundationTransactionRewards: (0, util_1.unwrap)(v1.foundationTransactionRewards?.value),
                nextPaydayTime: trTimestamp(v1.nextPaydayTime),
                nextPaydayMintRate: (0, util_1.unwrap)(v1.nextPaydayMintRate),
                totalStakedCapital: (0, util_1.unwrap)(v1.totalStakedCapital?.value),
            };
        }
        case undefined:
            throw new Error('Missing tokenomics info');
    }
}
exports.tokenomicsInfo = tokenomicsInfo;
function consensusInfo(ci) {
    return {
        bestBlock: unwrapValToHex(ci.bestBlock),
        genesisBlock: unwrapValToHex(ci.genesisBlock),
        currentEraGenesisBlock: unwrapValToHex(ci.currentEraGenesisBlock),
        lastFinalizedBlock: unwrapValToHex(ci.lastFinalizedBlock),
        epochDuration: (0, util_1.unwrap)(ci.epochDuration?.value),
        slotDuration: (0, util_1.unwrap)(ci.slotDuration?.value),
        bestBlockHeight: (0, util_1.unwrap)(ci.bestBlockHeight?.value),
        lastFinalizedBlockHeight: (0, util_1.unwrap)(ci.lastFinalizedBlockHeight?.value),
        finalizationCount: BigInt((0, util_1.unwrap)(ci.finalizationCount)),
        blocksVerifiedCount: BigInt((0, util_1.unwrap)(ci.blocksVerifiedCount)),
        blocksReceivedCount: BigInt((0, util_1.unwrap)(ci.blocksReceivedCount)),
        blockArriveLatencyEMA: (0, util_1.unwrap)(ci.blockArriveLatencyEma),
        blockArriveLatencyEMSD: (0, util_1.unwrap)(ci.blockArriveLatencyEmsd),
        blockReceiveLatencyEMA: (0, util_1.unwrap)(ci.blockReceiveLatencyEma),
        blockReceiveLatencyEMSD: (0, util_1.unwrap)(ci.blockReceiveLatencyEmsd),
        transactionsPerBlockEMA: (0, util_1.unwrap)(ci.transactionsPerBlockEma),
        transactionsPerBlockEMSD: (0, util_1.unwrap)(ci.transactionsPerBlockEmsd),
        genesisTime: trTimestamp(ci.genesisTime),
        currentEraGenesisTime: trTimestamp(ci.currentEraGenesisTime),
        genesisIndex: (0, util_1.unwrap)(ci.genesisIndex?.value),
        protocolVersion: BigInt((0, util_1.unwrap)(ci.protocolVersion)),
        // Only include the following if they are not undefined
        ...(ci.blockReceivePeriodEma && {
            blockReceivePeriodEMA: ci.blockReceivePeriodEma,
        }),
        ...(ci.blockReceivePeriodEmsd && {
            blockReceivePeriodEMSD: ci.blockReceivePeriodEmsd,
        }),
        ...(ci.blockArrivePeriodEma && {
            blockArrivePeriodEMA: ci.blockArrivePeriodEma,
        }),
        ...(ci.blockArrivePeriodEmsd && {
            blockArrivePeriodEMSD: ci.blockArrivePeriodEmsd,
        }),
        ...(ci.finalizationPeriodEma && {
            blockArrivePeriodEMA: ci.blockArrivePeriodEma,
        }),
        ...(ci.finalizationPeriodEmsd && {
            blockArrivePeriodEMSD: ci.blockArrivePeriodEmsd,
        }),
        ...(ci.blockLastReceivedTime && {
            blockLastReceivedTime: trTimestamp(ci.blockLastReceivedTime),
        }),
        ...(ci.blockLastArrivedTime && {
            blockLastArrivedTime: trTimestamp(ci.blockLastArrivedTime),
        }),
        ...(ci.lastFinalizedTime && {
            lastFinalizedTime: trTimestamp(ci.lastFinalizedTime),
        }),
    };
}
exports.consensusInfo = consensusInfo;
function trAccountAddress(accountAddress) {
    return {
        type: 'AddressAccount',
        address: unwrapToBase58(accountAddress),
    };
}
function trAddress(addr) {
    const accountAddress = (0, util_1.unwrap)(addr);
    const contractAddress = (0, util_1.unwrap)(addr);
    const address = (0, util_1.unwrap)(addr);
    if (accountAddress.value) {
        return trAccountAddress(accountAddress);
    }
    else if (contractAddress.index) {
        return {
            type: 'AddressContract',
            address: contractAddress,
        };
    }
    else if (address.type.oneofKind === 'account') {
        return trAccountAddress(address.type.account);
    }
    else if (address.type.oneofKind === 'contract') {
        return {
            type: 'AddressContract',
            address: address.type.contract,
        };
    }
    else {
        throw Error('Invalid address encountered!');
    }
}
function trContractTraceElement(contractTraceElement) {
    const element = contractTraceElement.element;
    switch (element.oneofKind) {
        case 'updated':
            return {
                tag: v1.TransactionEventTag.Updated,
                contractVersion: element.updated.contractVersion,
                address: (0, util_1.unwrap)(element.updated.address),
                instigator: trAddress(element.updated.instigator),
                amount: (0, util_1.unwrap)(element.updated.amount?.value),
                message: unwrapValToHex(element.updated.parameter),
                receiveName: (0, util_1.unwrap)(element.updated.receiveName?.value),
                events: element.updated.events.map(unwrapValToHex),
            };
        case 'transferred':
            return {
                tag: v1.TransactionEventTag.Transferred,
                from: trAddress(element.transferred.sender),
                amount: (0, util_1.unwrap)(element.transferred.amount?.value),
                to: trAddress(element.transferred.receiver),
            };
        case 'interrupted':
            return {
                tag: v1.TransactionEventTag.Interrupted,
                address: (0, util_1.unwrap)(element.interrupted.address),
                events: element.interrupted.events.map(unwrapValToHex),
            };
        case 'resumed':
            return {
                tag: v1.TransactionEventTag.Resumed,
                address: (0, util_1.unwrap)(element.resumed.address),
                success: (0, util_1.unwrap)(element.resumed.success),
            };
        case 'upgraded':
            return {
                tag: v1.TransactionEventTag.Upgraded,
                address: (0, util_1.unwrap)(element.upgraded.address),
                from: unwrapValToHex(element.upgraded.from),
                to: unwrapValToHex(element.upgraded.to),
            };
        default:
            throw Error('Invalid ContractTraceElement received, not able to translate to Transaction Event!');
    }
}
function trBakerEvent(bakerEvent, account) {
    const event = bakerEvent.event;
    switch (event.oneofKind) {
        case 'bakerAdded': {
            const keysEvent = event.bakerAdded.keysEvent;
            return {
                tag: v1.TransactionEventTag.BakerAdded,
                bakerId: (0, util_1.unwrap)(keysEvent?.bakerId?.value),
                account: unwrapToBase58(keysEvent?.account),
                signKey: unwrapValToHex(keysEvent?.signKey),
                electionKey: unwrapValToHex(keysEvent?.electionKey),
                aggregationKey: unwrapValToHex(keysEvent?.aggregationKey),
                stake: (0, util_1.unwrap)(event.bakerAdded.stake?.value),
                restakeEarnings: (0, util_1.unwrap)(event.bakerAdded.restakeEarnings),
            };
        }
        case 'bakerRemoved':
            return {
                tag: v1.TransactionEventTag.BakerRemoved,
                bakerId: (0, util_1.unwrap)(event.bakerRemoved.value),
                account,
            };
        case 'bakerStakeIncreased':
            return {
                tag: v1.TransactionEventTag.BakerStakeIncreased,
                bakerId: (0, util_1.unwrap)(event.bakerStakeIncreased.bakerId?.value),
                newStake: (0, util_1.unwrap)(event.bakerStakeIncreased.newStake?.value),
                account,
            };
        case 'bakerStakeDecreased':
            return {
                tag: v1.TransactionEventTag.BakerStakeDecreased,
                bakerId: (0, util_1.unwrap)(event.bakerStakeDecreased.bakerId?.value),
                newStake: (0, util_1.unwrap)(event.bakerStakeDecreased.newStake?.value),
                account,
            };
        case 'bakerRestakeEarningsUpdated': {
            const update = event.bakerRestakeEarningsUpdated;
            return {
                tag: v1.TransactionEventTag.BakerSetRestakeEarnings,
                bakerId: (0, util_1.unwrap)(update.bakerId?.value),
                restakeEarnings: (0, util_1.unwrap)(update.restakeEarnings),
                account,
            };
        }
        case 'bakerKeysUpdated':
            return {
                tag: v1.TransactionEventTag.BakerKeysUpdated,
                bakerId: (0, util_1.unwrap)(event.bakerKeysUpdated.bakerId?.value),
                account: unwrapToBase58(event.bakerKeysUpdated.account),
                signKey: unwrapValToHex(event.bakerKeysUpdated.signKey),
                electionKey: unwrapValToHex(event.bakerKeysUpdated.electionKey),
                aggregationKey: unwrapValToHex(event.bakerKeysUpdated.aggregationKey),
            };
        case 'bakerSetOpenStatus': {
            const setOpenStatus = event.bakerSetOpenStatus;
            return {
                tag: v1.TransactionEventTag.BakerSetOpenStatus,
                bakerId: (0, util_1.unwrap)(setOpenStatus.bakerId?.value),
                openStatus: trOpenStatus(setOpenStatus.openStatus),
                account,
            };
        }
        case 'bakerSetMetadataUrl': {
            const setURL = event.bakerSetMetadataUrl;
            return {
                tag: v1.TransactionEventTag.BakerSetMetadataURL,
                bakerId: (0, util_1.unwrap)(setURL.bakerId?.value),
                metadataURL: setURL.url,
                account,
            };
        }
        case 'bakerSetTransactionFeeCommission': {
            const transferFeeComm = event.bakerSetTransactionFeeCommission;
            const amount = transferFeeComm.transactionFeeCommission;
            return {
                tag: v1.TransactionEventTag.BakerSetTransactionFeeCommission,
                bakerId: (0, util_1.unwrap)(transferFeeComm.bakerId?.value),
                transactionFeeCommission: trAmountFraction(amount),
                account,
            };
        }
        case 'bakerSetBakingRewardCommission': {
            const rewardComm = event.bakerSetBakingRewardCommission;
            const amount = rewardComm.bakingRewardCommission;
            return {
                tag: v1.TransactionEventTag.BakerSetBakingRewardCommission,
                bakerId: (0, util_1.unwrap)(rewardComm.bakerId?.value),
                bakingRewardCommission: trAmountFraction(amount),
                account,
            };
        }
        case 'bakerSetFinalizationRewardCommission': {
            const rewardComm = event.bakerSetFinalizationRewardCommission;
            const amount = rewardComm.finalizationRewardCommission;
            return {
                tag: v1.TransactionEventTag
                    .BakerSetFinalizationRewardCommission,
                bakerId: (0, util_1.unwrap)(rewardComm.bakerId?.value),
                finalizationRewardCommission: trAmountFraction(amount),
                account,
            };
        }
        case undefined:
            throw Error('Failed translating BakerEvent, encountered undefined');
    }
}
function trDelegTarget(delegationTarget) {
    const target = delegationTarget?.target;
    if (target?.oneofKind === 'baker') {
        return {
            delegateType: v1.DelegationTargetType.Baker,
            bakerId: Number((0, util_1.unwrap)(target.baker.value)),
        };
    }
    else if (target?.oneofKind === 'passive') {
        return {
            delegateType: v1.DelegationTargetType.PassiveDelegation,
        };
    }
    else {
        throw 'Failed translating DelegationTarget, encountered undefined';
    }
}
function trDelegationEvent(delegationEvent, account) {
    const event = delegationEvent.event;
    switch (event.oneofKind) {
        case 'delegationStakeIncreased': {
            const stakeIncr = event.delegationStakeIncreased;
            return {
                tag: v1.TransactionEventTag.DelegationStakeIncreased,
                delegatorId: Number((0, util_1.unwrap)(stakeIncr.delegatorId?.id?.value)),
                newStake: (0, util_1.unwrap)(stakeIncr.newStake?.value),
                account,
            };
        }
        case 'delegationStakeDecreased': {
            const stakeDecr = event.delegationStakeDecreased;
            return {
                tag: v1.TransactionEventTag.DelegationStakeDecreased,
                delegatorId: Number((0, util_1.unwrap)(stakeDecr.delegatorId?.id?.value)),
                newStake: (0, util_1.unwrap)(stakeDecr.newStake?.value),
                account,
            };
        }
        case 'delegationSetRestakeEarnings': {
            const restake = event.delegationSetRestakeEarnings;
            return {
                tag: v1.TransactionEventTag.DelegationSetRestakeEarnings,
                delegatorId: Number((0, util_1.unwrap)(restake.delegatorId?.id?.value)),
                restakeEarnings: (0, util_1.unwrap)(restake.restakeEarnings),
                account,
            };
        }
        case 'delegationSetDelegationTarget': {
            const target = event.delegationSetDelegationTarget;
            return {
                tag: v1.TransactionEventTag.DelegationSetDelegationTarget,
                delegatorId: Number((0, util_1.unwrap)(target.delegatorId?.id?.value)),
                delegationTarget: trDelegTarget(target.delegationTarget),
                account,
            };
        }
        case 'delegationAdded':
            return {
                tag: v1.TransactionEventTag.DelegationAdded,
                delegatorId: Number((0, util_1.unwrap)(event.delegationAdded.id?.value)),
                account,
            };
        case 'delegationRemoved':
            return {
                tag: v1.TransactionEventTag.DelegationRemoved,
                delegatorId: Number((0, util_1.unwrap)(event.delegationRemoved.id?.value)),
                account,
            };
        default:
            throw Error('Unrecognized event type. This should be impossible.');
    }
}
function trRejectReason(rejectReason) {
    function simpleReason(tag) {
        return {
            tag: v1.RejectReasonTag[tag],
        };
    }
    const reason = (0, util_1.unwrap)(rejectReason?.reason);
    const Tag = v1.RejectReasonTag;
    switch (reason.oneofKind) {
        case 'moduleNotWf':
            return simpleReason(Tag.ModuleNotWF);
        case 'runtimeFailure':
            return simpleReason(Tag.RuntimeFailure);
        case 'serializationFailure':
            return simpleReason(Tag.SerializationFailure);
        case 'outOfEnergy':
            return simpleReason(Tag.OutOfEnergy);
        case 'invalidProof':
            return simpleReason(Tag.InvalidProof);
        case 'insufficientBalanceForBakerStake':
            return simpleReason(Tag.InsufficientBalanceForBakerStake);
        case 'stakeUnderMinimumThresholdForBaking':
            return simpleReason(Tag.StakeUnderMinimumThresholdForBaking);
        case 'bakerInCooldown':
            return simpleReason(Tag.BakerInCooldown);
        case 'nonExistentCredentialId':
            return simpleReason(Tag.NonExistentCredentialID);
        case 'keyIndexAlreadyInUse':
            return simpleReason(Tag.KeyIndexAlreadyInUse);
        case 'invalidAccountThreshold':
            return simpleReason(Tag.InvalidAccountThreshold);
        case 'invalidCredentialKeySignThreshold':
            return simpleReason(Tag.InvalidCredentialKeySignThreshold);
        case 'invalidEncryptedAmountTransferProof':
            return simpleReason(Tag.InvalidEncryptedAmountTransferProof);
        case 'invalidTransferToPublicProof':
            return simpleReason(Tag.InvalidTransferToPublicProof);
        case 'invalidIndexOnEncryptedTransfer':
            return simpleReason(Tag.InvalidIndexOnEncryptedTransfer);
        case 'zeroScheduledAmount':
            return simpleReason(Tag.ZeroScheduledAmount);
        case 'nonIncreasingSchedule':
            return simpleReason(Tag.NonIncreasingSchedule);
        case 'firstScheduledReleaseExpired':
            return simpleReason(Tag.FirstScheduledReleaseExpired);
        case 'invalidCredentials':
            return simpleReason(Tag.InvalidCredentials);
        case 'removeFirstCredential':
            return simpleReason(Tag.RemoveFirstCredential);
        case 'credentialHolderDidNotSign':
            return simpleReason(Tag.CredentialHolderDidNotSign);
        case 'notAllowedMultipleCredentials':
            return simpleReason(Tag.NotAllowedMultipleCredentials);
        case 'notAllowedToReceiveEncrypted':
            return simpleReason(Tag.NotAllowedToReceiveEncrypted);
        case 'notAllowedToHandleEncrypted':
            return simpleReason(Tag.NotAllowedToHandleEncrypted);
        case 'missingBakerAddParameters':
            return simpleReason(Tag.MissingBakerAddParameters);
        case 'finalizationRewardCommissionNotInRange':
            return simpleReason(Tag.FinalizationRewardCommissionNotInRange);
        case 'bakingRewardCommissionNotInRange':
            return simpleReason(Tag.BakingRewardCommissionNotInRange);
        case 'transactionFeeCommissionNotInRange':
            return simpleReason(Tag.TransactionFeeCommissionNotInRange);
        case 'alreadyADelegator':
            return simpleReason(Tag.AlreadyADelegator);
        case 'insufficientBalanceForDelegationStake':
            return simpleReason(Tag.InsufficientBalanceForDelegationStake);
        case 'missingDelegationAddParameters':
            return simpleReason(Tag.MissingDelegationAddParameters);
        case 'insufficientDelegationStake':
            return simpleReason(Tag.InsufficientDelegationStake);
        case 'delegatorInCooldown':
            return simpleReason(Tag.DelegatorInCooldown);
        case 'stakeOverMaximumThresholdForPool':
            return simpleReason(Tag.StakeOverMaximumThresholdForPool);
        case 'poolWouldBecomeOverDelegated':
            return simpleReason(Tag.PoolWouldBecomeOverDelegated);
        case 'poolClosed':
            return simpleReason(Tag.PoolClosed);
        case 'moduleHashAlreadyExists':
            return {
                tag: Tag.ModuleHashAlreadyExists,
                contents: unwrapValToHex(reason.moduleHashAlreadyExists),
            };
        case 'invalidAccountReference':
            return {
                tag: Tag.InvalidAccountReference,
                contents: unwrapToBase58(reason.invalidAccountReference),
            };
        case 'invalidInitMethod':
            return {
                tag: Tag.InvalidInitMethod,
                contents: {
                    moduleRef: unwrapValToHex(reason.invalidInitMethod.moduleRef),
                    initName: (0, util_1.unwrap)(reason.invalidInitMethod.initName?.value),
                },
            };
        case 'invalidReceiveMethod':
            return {
                tag: Tag.InvalidReceiveMethod,
                contents: {
                    moduleRef: unwrapValToHex(reason.invalidReceiveMethod.moduleRef),
                    receiveName: (0, util_1.unwrap)(reason.invalidReceiveMethod.receiveName?.value),
                },
            };
        case 'invalidModuleReference':
            return {
                tag: Tag.InvalidModuleReference,
                contents: unwrapValToHex(reason.invalidModuleReference),
            };
        case 'invalidContractAddress':
            return {
                tag: Tag.InvalidContractAddress,
                contents: reason.invalidContractAddress,
            };
        case 'amountTooLarge':
            return {
                tag: Tag.AmountTooLarge,
                contents: {
                    address: trAddress(reason.amountTooLarge.address),
                    amount: (0, util_1.unwrap)(reason.amountTooLarge.amount?.value),
                },
            };
        case 'rejectedInit':
            return {
                tag: Tag.RejectedInit,
                rejectReason: reason.rejectedInit.rejectReason,
            };
        case 'rejectedReceive':
            return {
                tag: Tag.RejectedReceive,
                contractAddress: (0, util_1.unwrap)(reason.rejectedReceive.contractAddress),
                receiveName: (0, util_1.unwrap)(reason.rejectedReceive.receiveName?.value),
                rejectReason: (0, util_1.unwrap)(reason.rejectedReceive.rejectReason),
                parameter: unwrapValToHex(reason.rejectedReceive.parameter),
            };
        case 'alreadyABaker':
            return {
                tag: Tag.AlreadyABaker,
                contents: (0, util_1.unwrap)(reason.alreadyABaker.value),
            };
        case 'notABaker':
            return {
                tag: Tag.NotABaker,
                contents: unwrapToBase58(reason.notABaker),
            };
        case 'duplicateAggregationKey':
            return {
                tag: Tag.DuplicateAggregationKey,
                contents: unwrapValToHex(reason.duplicateAggregationKey),
            };
        case 'encryptedAmountSelfTransfer':
            return {
                tag: Tag.EncryptedAmountSelfTransfer,
                contents: unwrapToBase58(reason.encryptedAmountSelfTransfer),
            };
        case 'scheduledSelfTransfer':
            return {
                tag: Tag.ScheduledSelfTransfer,
                contents: unwrapToBase58(reason.scheduledSelfTransfer),
            };
        case 'duplicateCredIds':
            return {
                tag: Tag.DuplicateCredIDs,
                contents: reason.duplicateCredIds.ids.map(unwrapValToHex),
            };
        case 'nonExistentCredIds':
            return {
                tag: Tag.NonExistentCredIDs,
                contents: reason.nonExistentCredIds.ids.map(unwrapValToHex),
            };
        case 'notADelegator':
            return {
                tag: Tag.NotADelegator,
                contents: unwrapToBase58(reason.notADelegator),
            };
        case 'delegationTargetNotABaker':
            return {
                tag: Tag.DelegationTargetNotABaker,
                contents: (0, util_1.unwrap)(reason.delegationTargetNotABaker.value),
            };
        case undefined:
            throw Error('Failed translating RejectReason, encountered undefined value');
    }
}
function trMintRate(mintRate) {
    return (0, util_1.unwrap)(mintRate?.mantissa) * 10 ** (-1 * (0, util_1.unwrap)(mintRate?.exponent));
}
function trProtocolUpdate(update) {
    return {
        updateType: v1.UpdateType.Protocol,
        update: {
            message: update.message,
            specificationHash: unwrapValToHex(update.specificationHash),
            specificationUrl: update.specificationUrl,
            specificationAuxiliaryData: unwrapToHex(update.specificationAuxiliaryData),
        },
    };
}
function trElectionDifficultyUpdate(elecDiff) {
    return {
        updateType: v1.UpdateType.ElectionDifficulty,
        update: {
            electionDifficulty: trAmountFraction(elecDiff.value),
        },
    };
}
function trEuroPerEnergyUpdate(exchangeRate) {
    return {
        updateType: v1.UpdateType.EuroPerEnergy,
        update: (0, util_1.unwrap)(exchangeRate.value),
    };
}
function trMicroCcdPerEuroUpdate(exchangeRate) {
    return {
        updateType: v1.UpdateType.MicroGtuPerEuro,
        update: (0, util_1.unwrap)(exchangeRate.value),
    };
}
function trFoundationAccountUpdate(account) {
    return {
        updateType: v1.UpdateType.FoundationAccount,
        update: {
            address: unwrapToBase58(account),
        },
    };
}
function trTransactionFeeDistributionUpdate(transFeeDist) {
    return {
        updateType: v1.UpdateType.TransactionFeeDistribution,
        update: {
            baker: trAmountFraction(transFeeDist.baker),
            gasAccount: trAmountFraction(transFeeDist.gasAccount),
        },
    };
}
function trGasRewardsUpdate(gasRewards) {
    return {
        updateType: v1.UpdateType.GasRewards,
        update: {
            baker: trAmountFraction(gasRewards.baker),
            finalizationProof: trAmountFraction(gasRewards.finalizationProof),
            accountCreation: trAmountFraction(gasRewards.accountCreation),
            chainUpdate: trAmountFraction(gasRewards.accountCreation),
        },
    };
}
function trBakerStakeThresholdUpdate(bakerStakeThreshold) {
    return {
        updateType: v1.UpdateType.BakerStakeThreshold,
        update: {
            threshold: (0, util_1.unwrap)(bakerStakeThreshold.bakerStakeThreshold?.value),
        },
    };
}
function trPoolParametersCpv1Update(poolParams) {
    return {
        updateType: v1.UpdateType.PoolParameters,
        update: {
            passiveCommissions: {
                transactionCommission: trAmountFraction(poolParams.passiveTransactionCommission),
                bakingCommission: trAmountFraction(poolParams.passiveBakingCommission),
                finalizationCommission: trAmountFraction(poolParams.passiveFinalizationCommission),
            },
            commissionBounds: {
                transactionFeeCommission: trCommissionRange(poolParams.commissionBounds?.transaction),
                bakingRewardCommission: trCommissionRange(poolParams.commissionBounds?.baking),
                finalizationRewardCommission: trCommissionRange(poolParams.commissionBounds?.finalization),
            },
            minimumEquityCapital: (0, util_1.unwrap)(poolParams.minimumEquityCapital?.value),
            capitalBound: trAmountFraction(poolParams.capitalBound?.value),
            leverageBound: (0, util_1.unwrap)(poolParams.leverageBound?.value),
        },
    };
}
function trAddAnonymityRevokerUpdate(ar) {
    return {
        updateType: v1.UpdateType.AddAnonymityRevoker,
        update: arInfo(ar),
    };
}
function trAddIdentityProviderUpdate(ip) {
    return {
        updateType: v1.UpdateType.AddIdentityProvider,
        update: ipInfo(ip),
    };
}
function trCooldownParametersCpv1Update(cooldownParams) {
    return {
        updateType: v1.UpdateType.CooldownParameters,
        update: {
            poolOwnerCooldown: (0, util_1.unwrap)(cooldownParams.poolOwnerCooldown?.value),
            delegatorCooldown: (0, util_1.unwrap)(cooldownParams.delegatorCooldown?.value),
        },
    };
}
function trTimeParametersCpv1Update(timeParams) {
    return {
        updateType: v1.UpdateType.TimeParameters,
        update: {
            rewardPeriodLength: (0, util_1.unwrap)(timeParams.rewardPeriodLength?.value?.value),
            mintRatePerPayday: (0, util_1.unwrap)(timeParams.mintPerPayday),
        },
    };
}
function trMintDistributionCpv0Update(mintDist) {
    return {
        updateType: v1.UpdateType.MintDistribution,
        update: {
            bakingReward: trAmountFraction(mintDist.bakingReward),
            finalizationReward: trAmountFraction(mintDist.finalizationReward),
            mintPerSlot: trMintRate(mintDist.mintPerSlot),
        },
    };
}
function trMintDistributionCpv1Update(mintDist) {
    return {
        updateType: v1.UpdateType.MintDistribution,
        update: {
            bakingReward: trAmountFraction(mintDist.bakingReward),
            finalizationReward: trAmountFraction(mintDist.finalizationReward),
        },
    };
}
function pendingUpdate(pendingUpdate) {
    const effect = pendingUpdate.effect;
    switch (effect.oneofKind) {
        case 'protocol':
            return trProtocolUpdate(effect.protocol);
        case 'electionDifficulty':
            return trElectionDifficultyUpdate(effect.electionDifficulty);
        case 'euroPerEnergy':
            return trEuroPerEnergyUpdate(effect.euroPerEnergy);
        case 'microCcdPerEuro':
            return trMicroCcdPerEuroUpdate(effect.microCcdPerEuro);
        case 'foundationAccount':
            return trFoundationAccountUpdate(effect.foundationAccount);
        case 'transactionFeeDistribution':
            return trTransactionFeeDistributionUpdate(effect.transactionFeeDistribution);
        case 'gasRewards':
            return trGasRewardsUpdate(effect.gasRewards);
        case 'poolParametersCpv0':
            return trBakerStakeThresholdUpdate(effect.poolParametersCpv0);
        case 'poolParametersCpv1':
            return trPoolParametersCpv1Update(effect.poolParametersCpv1);
        case 'addAnonymityRevoker':
            return trAddAnonymityRevokerUpdate(effect.addAnonymityRevoker);
        case 'addIdentityProvider':
            return trAddIdentityProviderUpdate(effect.addIdentityProvider);
        case 'cooldownParameters':
            return trCooldownParametersCpv1Update(effect.cooldownParameters);
        case 'timeParameters':
            return trTimeParametersCpv1Update(effect.timeParameters);
        case 'mintDistributionCpv0':
            return trMintDistributionCpv0Update(effect.mintDistributionCpv0);
        case 'mintDistributionCpv1':
            return trMintDistributionCpv1Update(effect.mintDistributionCpv1);
        case 'rootKeys':
            return {
                updateType: v1.UpdateType.HigherLevelKeyUpdate,
                update: {
                    typeOfUpdate: v1.HigherLevelKeyUpdateType.RootKeysUpdate,
                    updateKeys: effect.rootKeys.keys.map(trUpdatePublicKey),
                    threshold: (0, util_1.unwrap)(effect.rootKeys.threshold?.value),
                },
            };
        case 'level1Keys':
            return {
                updateType: v1.UpdateType.HigherLevelKeyUpdate,
                update: {
                    typeOfUpdate: v1.HigherLevelKeyUpdateType.Level1KeysUpdate,
                    updateKeys: effect.level1Keys.keys.map(trUpdatePublicKey),
                    threshold: (0, util_1.unwrap)(effect.level1Keys.threshold?.value),
                },
            };
        case 'level2KeysCpv0':
            return {
                updateType: v1.UpdateType.AuthorizationKeysUpdate,
                update: {
                    typeOfUpdate: v1.AuthorizationKeysUpdateType.Level2KeysUpdate,
                    updatePayload: trAuthorizationsV0(effect.level2KeysCpv0),
                },
            };
        case 'level2KeysCpv1':
            return {
                updateType: v1.UpdateType.AuthorizationKeysUpdate,
                update: {
                    typeOfUpdate: v1.AuthorizationKeysUpdateType.Level2KeysUpdateV1,
                    updatePayload: trAuthorizationsV1(effect.level2KeysCpv1),
                },
            };
        case undefined:
            throw Error('Unexpected missing pending update');
        default:
            // TODO support new updates
            throw Error('Unsupported update: ' + effect.oneofKind);
    }
}
exports.pendingUpdate = pendingUpdate;
function trUpdatePayload(updatePayload) {
    const payload = updatePayload?.payload;
    switch (payload?.oneofKind) {
        case 'protocolUpdate':
            return trProtocolUpdate(payload.protocolUpdate);
        case 'electionDifficultyUpdate':
            return trElectionDifficultyUpdate(payload.electionDifficultyUpdate);
        case 'euroPerEnergyUpdate':
            return trEuroPerEnergyUpdate(payload.euroPerEnergyUpdate);
        case 'microCcdPerEuroUpdate':
            return trMicroCcdPerEuroUpdate(payload.microCcdPerEuroUpdate);
        case 'foundationAccountUpdate':
            return trFoundationAccountUpdate(payload.foundationAccountUpdate);
        case 'mintDistributionUpdate':
            return trMintDistributionCpv1Update(payload.mintDistributionUpdate);
        case 'transactionFeeDistributionUpdate':
            return trTransactionFeeDistributionUpdate(payload.transactionFeeDistributionUpdate);
        case 'gasRewardsUpdate':
            return trGasRewardsUpdate(payload.gasRewardsUpdate);
        case 'bakerStakeThresholdUpdate':
            return trBakerStakeThresholdUpdate(payload.bakerStakeThresholdUpdate);
        case 'addAnonymityRevokerUpdate':
            return trAddAnonymityRevokerUpdate(payload.addAnonymityRevokerUpdate);
        case 'addIdentityProviderUpdate':
            return trAddIdentityProviderUpdate(payload.addIdentityProviderUpdate);
        case 'cooldownParametersCpv1Update':
            return trCooldownParametersCpv1Update(payload.cooldownParametersCpv1Update);
        case 'poolParametersCpv1Update':
            return trPoolParametersCpv1Update(payload.poolParametersCpv1Update);
        case 'timeParametersCpv1Update':
            return trTimeParametersCpv1Update(payload.timeParametersCpv1Update);
        case 'mintDistributionCpv1Update':
            return trMintDistributionCpv1Update(payload.mintDistributionCpv1Update);
        case 'rootUpdate': {
            const rootUpdate = payload.rootUpdate;
            const keyUpdate = trKeyUpdate(rootUpdate);
            return {
                updateType: v1.UpdateType.Root,
                update: keyUpdate,
            };
        }
        case 'level1Update': {
            const lvl1Update = payload.level1Update;
            const keyUpdate = trKeyUpdate(lvl1Update);
            return {
                updateType: v1.UpdateType.Level1,
                update: keyUpdate,
            };
        }
        case undefined:
            throw new Error('Unexpected missing update payload');
        default:
            // TODO support new updates
            throw Error('Unsupported update payload type: ' + payload?.oneofKind);
    }
}
function trCommissionRange(range) {
    return {
        min: trAmountFraction(range?.min),
        max: trAmountFraction(range?.max),
    };
}
function trUpdatePublicKey(key) {
    return {
        schemeId: 'Ed25519',
        verifyKey: unwrapValToHex(key),
    };
}
function trAccessStructure(auths) {
    return {
        authorizedKeys: (0, util_1.unwrap)(auths).accessPublicKeys.map((key) => key.value),
        threshold: (0, util_1.unwrap)(auths?.accessThreshold?.value),
    };
}
function trKeyUpdate(keyUpdate) {
    switch (keyUpdate.updateType.oneofKind) {
        case 'rootKeysUpdate': {
            const update = keyUpdate.updateType.rootKeysUpdate;
            return {
                typeOfUpdate: v1.HigherLevelKeyUpdateType.RootKeysUpdate,
                updateKeys: update.keys.map(trUpdatePublicKey),
                threshold: (0, util_1.unwrap)(update.threshold?.value),
            };
        }
        case 'level1KeysUpdate': {
            const update = keyUpdate.updateType.level1KeysUpdate;
            return {
                typeOfUpdate: v1.HigherLevelKeyUpdateType.Level1KeysUpdate,
                updateKeys: update.keys.map(trUpdatePublicKey),
                threshold: (0, util_1.unwrap)(update.threshold?.value),
            };
        }
        case 'level2KeysUpdateV0': {
            const update = keyUpdate.updateType.level2KeysUpdateV0;
            return {
                typeOfUpdate: v1.AuthorizationKeysUpdateType.Level2KeysUpdate,
                updatePayload: trAuthorizationsV0(update),
            };
        }
        case 'level2KeysUpdateV1': {
            const update = keyUpdate.updateType.level2KeysUpdateV1;
            const v0 = (0, util_1.unwrap)(update.v0);
            return {
                typeOfUpdate: v1.AuthorizationKeysUpdateType.Level2KeysUpdateV1,
                updatePayload: {
                    ...trAuthorizationsV0(v0),
                    cooldownParameters: trAccessStructure(update.parameterCooldown),
                    timeParameters: trAccessStructure(update.parameterTime),
                },
            };
        }
        case undefined:
            throw new Error('Unexpected missing update type');
    }
}
function trAuthorizationsV0(auths) {
    return {
        keys: auths.keys.map(trUpdatePublicKey),
        addIdentityProvider: trAccessStructure(auths.addIdentityProvider),
        addAnonymityRevoker: trAccessStructure(auths.addAnonymityRevoker),
        emergency: trAccessStructure(auths.emergency),
        electionDifficulty: trAccessStructure(auths.parameterConsensus),
        euroPerEnergy: trAccessStructure(auths.parameterEuroPerEnergy),
        foundationAccount: trAccessStructure(auths.parameterFoundationAccount),
        microGTUPerEuro: trAccessStructure(auths.parameterMicroCCDPerEuro),
        paramGASRewards: trAccessStructure(auths.parameterGasRewards),
        mintDistribution: trAccessStructure(auths.parameterMintDistribution),
        transactionFeeDistribution: trAccessStructure(auths.parameterTransactionFeeDistribution),
        poolParameters: trAccessStructure(auths.poolParameters),
        protocol: trAccessStructure(auths.protocol),
    };
}
function trAuthorizationsV1(auths) {
    return {
        ...trAuthorizationsV0((0, util_1.unwrap)(auths.v0)),
        cooldownParameters: trAccessStructure(auths.parameterCooldown),
        timeParameters: trAccessStructure(auths.parameterTime),
    };
}
function trMemoEvent(memo) {
    return {
        tag: v1.TransactionEventTag.TransferMemo,
        memo: unwrapValToHex(memo),
    };
}
function trTransactionType(type) {
    switch (type) {
        case v2.TransactionType.DEPLOY_MODULE:
            return v1.TransactionKindString.DeployModule;
        case v2.TransactionType.INIT_CONTRACT:
            return v1.TransactionKindString.InitContract;
        case v2.TransactionType.UPDATE:
            return v1.TransactionKindString.Update;
        case v2.TransactionType.TRANSFER:
            return v1.TransactionKindString.Transfer;
        case v2.TransactionType.ADD_BAKER:
            return v1.TransactionKindString.AddBaker;
        case v2.TransactionType.REMOVE_BAKER:
            return v1.TransactionKindString.RemoveBaker;
        case v2.TransactionType.UPDATE_BAKER_STAKE:
            return v1.TransactionKindString.UpdateBakerStake;
        case v2.TransactionType.UPDATE_BAKER_RESTAKE_EARNINGS:
            return v1.TransactionKindString.UpdateBakerRestakeEarnings;
        case v2.TransactionType.UPDATE_BAKER_KEYS:
            return v1.TransactionKindString.UpdateBakerKeys;
        case v2.TransactionType.UPDATE_CREDENTIAL_KEYS:
            return v1.TransactionKindString.UpdateCredentialKeys;
        case v2.TransactionType.ENCRYPTED_AMOUNT_TRANSFER:
            return v1.TransactionKindString.EncryptedAmountTransfer;
        case v2.TransactionType.TRANSFER_TO_ENCRYPTED:
            return v1.TransactionKindString.TransferToEncrypted;
        case v2.TransactionType.TRANSFER_TO_PUBLIC:
            return v1.TransactionKindString.TransferToPublic;
        case v2.TransactionType.TRANSFER_WITH_SCHEDULE:
            return v1.TransactionKindString.TransferWithSchedule;
        case v2.TransactionType.UPDATE_CREDENTIALS:
            return v1.TransactionKindString.UpdateCredentials;
        case v2.TransactionType.REGISTER_DATA:
            return v1.TransactionKindString.RegisterData;
        case v2.TransactionType.TRANSFER_WITH_MEMO:
            return v1.TransactionKindString.TransferWithMemo;
        case v2.TransactionType.ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO:
            return v1.TransactionKindString.EncryptedAmountTransferWithMemo;
        case v2.TransactionType.TRANSFER_WITH_SCHEDULE_AND_MEMO:
            return v1.TransactionKindString.TransferWithScheduleAndMemo;
        case v2.TransactionType.CONFIGURE_BAKER:
            return v1.TransactionKindString.ConfigureBaker;
        case v2.TransactionType.CONFIGURE_DELEGATION:
            return v1.TransactionKindString.ConfigureDelegation;
        case undefined:
            return undefined;
    }
}
function trAccountTransactionSummary(details, baseBlockItemSummary) {
    const base = {
        ...baseBlockItemSummary,
        type: v1.TransactionSummaryType.AccountTransaction,
        cost: (0, util_1.unwrap)(details.cost?.value),
        sender: unwrapToBase58(details.sender),
    };
    const effect = (0, util_1.unwrap)(details.effects?.effect);
    switch (effect.oneofKind) {
        case 'none':
            return {
                ...base,
                transactionType: v1.TransactionKindString.Failed,
                failedTransactionType: trTransactionType(effect.none.transactionType),
                rejectReason: trRejectReason(effect.none.rejectReason),
            };
        case 'moduleDeployed': {
            const event = {
                tag: v1.TransactionEventTag.ModuleDeployed,
                contents: unwrapValToHex(effect.moduleDeployed),
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.DeployModule,
                moduleDeployed: event,
            };
        }
        case 'contractInitialized': {
            const contractInit = effect.contractInitialized;
            const event = {
                tag: v1.TransactionEventTag.ContractInitialized,
                address: (0, util_1.unwrap)(contractInit.address),
                amount: (0, util_1.unwrap)(contractInit.amount?.value),
                initName: (0, util_1.unwrap)(contractInit.initName?.value),
                events: (0, util_1.unwrap)(contractInit.events.map(unwrapValToHex)),
                contractVersion: (0, util_1.unwrap)(contractInit.contractVersion),
                ref: unwrapValToHex(contractInit.originRef),
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.InitContract,
                contractInitialized: event,
            };
        }
        case 'contractUpdateIssued':
            return {
                ...base,
                transactionType: v1.TransactionKindString.Update,
                events: effect.contractUpdateIssued.effects.map(trContractTraceElement),
            };
        case 'accountTransfer': {
            const transfer = {
                tag: v1.TransactionEventTag.Transferred,
                amount: (0, util_1.unwrap)(effect.accountTransfer.amount?.value),
                to: trAccountAddress(effect.accountTransfer.receiver).address,
            };
            if (effect.accountTransfer.memo) {
                return {
                    ...base,
                    transactionType: v1.TransactionKindString.TransferWithMemo,
                    transfer,
                    memo: trMemoEvent(effect.accountTransfer.memo),
                };
            }
            else {
                return {
                    ...base,
                    transactionType: v1.TransactionKindString.Transfer,
                    transfer,
                };
            }
        }
        case 'bakerAdded':
            return {
                ...base,
                transactionType: v1.TransactionKindString.AddBaker,
                bakerAdded: trBakerEvent({
                    event: effect,
                }, base.sender),
            };
        case 'bakerRemoved':
            return {
                ...base,
                transactionType: v1.TransactionKindString.RemoveBaker,
                bakerRemoved: trBakerEvent({
                    event: effect,
                }, base.sender),
            };
        case 'bakerRestakeEarningsUpdated':
            return {
                ...base,
                transactionType: v1.TransactionKindString.UpdateBakerRestakeEarnings,
                bakerRestakeEarningsUpdated: trBakerEvent({
                    event: effect,
                }, base.sender),
            };
        case 'bakerKeysUpdated':
            return {
                ...base,
                transactionType: v1.TransactionKindString.UpdateBakerKeys,
                bakerKeysUpdated: trBakerEvent({
                    event: effect,
                }, base.sender),
            };
        case 'bakerStakeUpdated': {
            const increased = effect.bakerStakeUpdated.update?.increased;
            const update = effect.bakerStakeUpdated.update;
            const event = {
                tag: increased
                    ? v1.TransactionEventTag.BakerStakeIncreased
                    : v1.TransactionEventTag.BakerStakeDecreased,
                bakerId: (0, util_1.unwrap)(update?.bakerId?.value),
                newStake: (0, util_1.unwrap)(update?.newStake?.value),
                account: base.sender,
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.UpdateBakerStake,
                bakerStakeChanged: event,
            };
        }
        case 'encryptedAmountTransferred': {
            const transfer = effect.encryptedAmountTransferred;
            const removed = {
                tag: v1.TransactionEventTag.EncryptedAmountsRemoved,
                inputAmount: unwrapValToHex(transfer.removed?.inputAmount),
                newAmount: unwrapValToHex(transfer.removed?.newAmount),
                upToIndex: Number((0, util_1.unwrap)(transfer.removed?.upToIndex)),
                account: base.sender,
            };
            const added = {
                tag: v1.TransactionEventTag.NewEncryptedAmount,
                account: unwrapToBase58(transfer.added?.receiver),
                newIndex: Number((0, util_1.unwrap)(transfer.added?.newIndex)),
                encryptedAmount: unwrapValToHex(transfer.added?.encryptedAmount),
            };
            if (transfer.memo) {
                return {
                    ...base,
                    transactionType: v1.TransactionKindString
                        .EncryptedAmountTransferWithMemo,
                    removed,
                    added,
                    memo: trMemoEvent(transfer.memo),
                };
            }
            else {
                return {
                    ...base,
                    transactionType: v1.TransactionKindString.EncryptedAmountTransfer,
                    removed,
                    added,
                };
            }
        }
        case 'transferredToEncrypted': {
            const transfer = effect.transferredToEncrypted;
            const added = {
                tag: v1.TransactionEventTag.EncryptedSelfAmountAdded,
                account: unwrapToBase58(transfer.account),
                amount: (0, util_1.unwrap)(transfer.amount?.value),
                newAmount: unwrapValToHex(transfer.newAmount),
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.TransferToEncrypted,
                added,
            };
        }
        case 'transferredToPublic': {
            const transfer = effect.transferredToPublic;
            const removed = {
                tag: v1.TransactionEventTag.EncryptedAmountsRemoved,
                account: base.sender,
                inputAmount: unwrapValToHex(transfer.removed?.inputAmount),
                newAmount: unwrapValToHex(transfer.removed?.newAmount),
                upToIndex: Number((0, util_1.unwrap)(transfer.removed?.upToIndex)),
            };
            const added = {
                tag: v1.TransactionEventTag.AmountAddedByDecryption,
                account: base.sender,
                amount: (0, util_1.unwrap)(transfer.amount?.value),
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.TransferToPublic,
                removed,
                added,
            };
        }
        case 'transferredWithSchedule': {
            const transfer = effect.transferredWithSchedule;
            const event = {
                tag: v1.TransactionEventTag.TransferredWithSchedule,
                to: unwrapToBase58(transfer.receiver),
                amount: transfer.amount.map(trNewRelease),
            };
            if (transfer.memo) {
                return {
                    ...base,
                    transactionType: v1.TransactionKindString.TransferWithScheduleAndMemo,
                    transfer: event,
                    memo: trMemoEvent(transfer.memo),
                };
            }
            else {
                return {
                    ...base,
                    transactionType: v1.TransactionKindString.TransferWithSchedule,
                    event,
                };
            }
        }
        case 'credentialKeysUpdated': {
            const event = {
                tag: v1.TransactionEventTag.CredentialKeysUpdated,
                credId: unwrapValToHex(effect.credentialKeysUpdated),
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.UpdateCredentialKeys,
                keysUpdated: event,
            };
        }
        case 'credentialsUpdated': {
            const update = effect.credentialsUpdated;
            const event = {
                tag: v1.TransactionEventTag.CredentialsUpdated,
                newCredIds: update.newCredIds.map(unwrapValToHex),
                removedCredIds: update.removedCredIds.map(unwrapValToHex),
                newThreshold: (0, util_1.unwrap)(update.newThreshold?.value),
                account: base.sender,
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.UpdateCredentials,
                credentialsUpdated: event,
            };
        }
        case 'dataRegistered': {
            const event = {
                tag: v1.TransactionEventTag.DataRegistered,
                data: unwrapValToHex(effect.dataRegistered),
            };
            return {
                ...base,
                transactionType: v1.TransactionKindString.RegisterData,
                dataRegistered: event,
            };
        }
        case 'bakerConfigured':
            return {
                ...base,
                transactionType: v1.TransactionKindString.ConfigureBaker,
                events: effect.bakerConfigured.events.map((event) => trBakerEvent(event, base.sender)),
            };
        case 'delegationConfigured':
            return {
                ...base,
                transactionType: v1.TransactionKindString.ConfigureDelegation,
                events: effect.delegationConfigured.events.map((x) => trDelegationEvent(x, base.sender)),
            };
        case undefined:
            throw Error('Failed translating AccountTransactionEffects, encountered undefined value');
    }
}
function blockItemSummary(summary) {
    const base = {
        index: (0, util_1.unwrap)(summary.index?.value),
        energyCost: (0, util_1.unwrap)(summary.energyCost?.value),
        hash: unwrapValToHex(summary.hash),
    };
    if (summary.details.oneofKind === 'accountTransaction') {
        return trAccountTransactionSummary(summary.details.accountTransaction, base);
    }
    else if (summary.details.oneofKind === 'accountCreation') {
        return {
            type: v1.TransactionSummaryType.AccountCreation,
            ...base,
            credentialType: summary.details.accountCreation.credentialType ===
                v2.CredentialType.INITIAL
                ? 'initial'
                : 'normal',
            address: unwrapToBase58(summary.details.accountCreation.address),
            regId: unwrapValToHex(summary.details.accountCreation.regId),
        };
    }
    else if (summary.details.oneofKind === 'update') {
        return {
            type: v1.TransactionSummaryType.UpdateTransaction,
            ...base,
            effectiveTime: (0, util_1.unwrap)(summary.details.update.effectiveTime?.value),
            payload: trUpdatePayload(summary.details.update.payload),
        };
    }
    else {
        throw Error('Invalid BlockItemSummary encountered!');
    }
}
exports.blockItemSummary = blockItemSummary;
function trBlockItemSummaryInBlock(summary) {
    return {
        blockHash: unwrapValToHex(summary.blockHash),
        summary: blockItemSummary((0, util_1.unwrap)(summary.outcome)),
    };
}
function blockItemStatus(itemStatus) {
    switch (itemStatus.status.oneofKind) {
        case 'received':
            return {
                status: v1.TransactionStatusEnum.Received,
            };
        case 'committed':
            return {
                status: v1.TransactionStatusEnum.Committed,
                outcomes: itemStatus.status.committed.outcomes.map(trBlockItemSummaryInBlock),
            };
        case 'finalized':
            return {
                status: v1.TransactionStatusEnum.Finalized,
                outcome: trBlockItemSummaryInBlock((0, util_1.unwrap)(itemStatus.status.finalized.outcome)),
            };
        default:
            throw Error('BlockItemStatus was undefined!');
    }
}
exports.blockItemStatus = blockItemStatus;
function invokeInstanceResponse(invokeResponse) {
    switch (invokeResponse.result.oneofKind) {
        case 'failure':
            return {
                tag: 'failure',
                usedEnergy: (0, util_1.unwrap)(invokeResponse.result.failure.usedEnergy?.value),
                reason: trRejectReason(invokeResponse.result.failure.reason),
            };
        case 'success': {
            const result = invokeResponse.result.success;
            return {
                tag: 'success',
                usedEnergy: (0, util_1.unwrap)(result.usedEnergy?.value),
                returnValue: result.returnValue
                    ? buffer_1.Buffer.from((0, util_1.unwrap)(result.returnValue)).toString('hex')
                    : undefined,
                events: result.effects.map(trContractTraceElement),
            };
        }
        default:
            throw Error('BlockItemStatus was undefined!');
    }
}
exports.invokeInstanceResponse = invokeInstanceResponse;
function trInstanceInfoCommon(info) {
    return {
        amount: new ccdAmount_1.CcdAmount((0, util_1.unwrap)(info.amount?.value)),
        sourceModule: moduleReference_1.ModuleReference.fromBytes(buffer_1.Buffer.from((0, util_1.unwrap)(info.sourceModule?.value))),
        owner: accountAddress_1.AccountAddress.fromBytes(buffer_1.Buffer.from((0, util_1.unwrap)(info.owner?.value))),
        methods: info.methods.map((name) => name.value),
        name: (0, util_1.unwrap)(info.name?.value),
    };
}
function instanceInfo(instanceInfo) {
    switch (instanceInfo.version.oneofKind) {
        case 'v0':
            return {
                ...trInstanceInfoCommon(instanceInfo.version.v0),
                version: 0,
                model: buffer_1.Buffer.from((0, util_1.unwrap)(instanceInfo.version.v0.model?.value)),
            };
        case 'v1':
            return {
                ...trInstanceInfoCommon(instanceInfo.version.v1),
                version: 1,
            };
        default:
            throw Error('InstanceInfo was undefined');
    }
}
exports.instanceInfo = instanceInfo;
function commonBlockInfo(blockInfo) {
    return {
        hash: unwrapValToHex(blockInfo.hash),
        height: (0, util_1.unwrap)(blockInfo.height?.value),
    };
}
exports.commonBlockInfo = commonBlockInfo;
function instanceStateKVPair(state) {
    return {
        key: unwrapToHex(state.key),
        value: unwrapToHex(state.value),
    };
}
exports.instanceStateKVPair = instanceStateKVPair;
function ipInfo(ip) {
    return {
        ipIdentity: (0, util_1.unwrap)(ip.identity?.value),
        ipDescription: (0, util_1.unwrap)(ip.description),
        ipVerifyKey: unwrapValToHex(ip.verifyKey),
        ipCdiVerifyKey: unwrapValToHex(ip.cdiVerifyKey),
    };
}
exports.ipInfo = ipInfo;
function arInfo(ar) {
    return {
        arIdentity: (0, util_1.unwrap)(ar.identity?.value),
        arDescription: (0, util_1.unwrap)(ar.description),
        arPublicKey: unwrapValToHex(ar.publicKey),
    };
}
exports.arInfo = arInfo;
function blocksAtHeightResponse(blocks) {
    return blocks.blocks.map(unwrapValToHex);
}
exports.blocksAtHeightResponse = blocksAtHeightResponse;
function blockInfo(blockInfo) {
    return {
        blockParent: unwrapValToHex(blockInfo.parentBlock),
        blockHash: unwrapValToHex(blockInfo.hash),
        blockStateHash: unwrapValToHex(blockInfo.stateHash),
        blockLastFinalized: unwrapValToHex(blockInfo.lastFinalizedBlock),
        blockHeight: (0, util_1.unwrap)(blockInfo.height?.value),
        blockBaker: (0, util_1.unwrap)(blockInfo.baker?.value),
        blockSlot: (0, util_1.unwrap)(blockInfo.slotNumber?.value),
        blockArriveTime: trTimestamp(blockInfo.arriveTime),
        blockReceiveTime: trTimestamp(blockInfo.receiveTime),
        blockSlotTime: trTimestamp(blockInfo.slotTime),
        finalized: blockInfo.finalized,
        transactionCount: BigInt(blockInfo.transactionCount),
        transactionsSize: BigInt(blockInfo.transactionsSize),
        transactionEnergyCost: (0, util_1.unwrap)(blockInfo.transactionsEnergyCost?.value),
        genesisIndex: (0, util_1.unwrap)(blockInfo.genesisIndex?.value),
        eraBlockHeight: Number((0, util_1.unwrap)(blockInfo.eraBlockHeight?.value)),
    };
}
exports.blockInfo = blockInfo;
function delegatorInfo(delegatorInfo) {
    return {
        account: unwrapToBase58(delegatorInfo.account),
        stake: (0, util_1.unwrap)(delegatorInfo.stake?.value),
        ...(delegatorInfo.pendingChange && {
            pendingChange: trPendingChange(delegatorInfo.pendingChange),
        }),
    };
}
exports.delegatorInfo = delegatorInfo;
function branch(branchV2) {
    return {
        blockHash: unwrapValToHex(branchV2.blockHash),
        children: branchV2.children.map(branch),
    };
}
exports.branch = branch;
function trBakerElectionInfo(bakerElectionInfo) {
    return {
        baker: (0, util_1.unwrap)(bakerElectionInfo.baker?.value),
        account: unwrapToBase58(bakerElectionInfo.account),
        lotteryPower: bakerElectionInfo.lotteryPower,
    };
}
function electionInfo(electionInfo) {
    return {
        electionDifficulty: trAmountFraction(electionInfo.electionDifficulty?.value),
        electionNonce: unwrapValToHex(electionInfo.electionNonce),
        bakerElectionInfo: electionInfo.bakerElectionInfo.map(trBakerElectionInfo),
    };
}
exports.electionInfo = electionInfo;
function nextUpdateSequenceNumbers(nextNums) {
    return {
        rootKeys: (0, util_1.unwrap)(nextNums.rootKeys?.value),
        level1Keys: (0, util_1.unwrap)(nextNums.level1Keys?.value),
        level2Keys: (0, util_1.unwrap)(nextNums.level2Keys?.value),
        protocol: (0, util_1.unwrap)(nextNums.protocol?.value),
        electionDifficulty: (0, util_1.unwrap)(nextNums.electionDifficulty?.value),
        euroPerEnergy: (0, util_1.unwrap)(nextNums.euroPerEnergy?.value),
        microCcdPerEuro: (0, util_1.unwrap)(nextNums.microCcdPerEuro?.value),
        foundationAccount: (0, util_1.unwrap)(nextNums.foundationAccount?.value),
        mintDistribution: (0, util_1.unwrap)(nextNums.mintDistribution?.value),
        transactionFeeDistribution: (0, util_1.unwrap)(nextNums.transactionFeeDistribution?.value),
        gasRewards: (0, util_1.unwrap)(nextNums.gasRewards?.value),
        poolParameters: (0, util_1.unwrap)(nextNums.poolParameters?.value),
        addAnonymityRevoker: (0, util_1.unwrap)(nextNums.addAnonymityRevoker?.value),
        addIdentityProvider: (0, util_1.unwrap)(nextNums.addIdentityProvider?.value),
        cooldownParameters: (0, util_1.unwrap)(nextNums.cooldownParameters?.value),
        timeParameters: (0, util_1.unwrap)(nextNums.timeParameters?.value),
    };
}
exports.nextUpdateSequenceNumbers = nextUpdateSequenceNumbers;
function trPassiveCommitteeInfo(passiveCommitteeInfo) {
    const passiveCommitteeInfoV2 = v2.NodeInfo_BakerConsensusInfo_PassiveCommitteeInfo;
    switch (passiveCommitteeInfo) {
        case passiveCommitteeInfoV2.NOT_IN_COMMITTEE:
            return v1.PassiveCommitteeInfo.NotInCommittee;
        case passiveCommitteeInfoV2.ADDED_BUT_NOT_ACTIVE_IN_COMMITTEE:
            return v1.PassiveCommitteeInfo.AddedButNotActiveInCommittee;
        case passiveCommitteeInfoV2.ADDED_BUT_WRONG_KEYS:
            return v1.PassiveCommitteeInfo.AddedButWrongKeys;
    }
}
function trBakerConsensusInfoStatus(consensusInfo) {
    if (consensusInfo.status.oneofKind === 'passiveCommitteeInfo') {
        return {
            tag: 'passiveCommitteeInfo',
            passiveCommitteeInfo: trPassiveCommitteeInfo(consensusInfo.status.passiveCommitteeInfo),
        };
    }
    else if (consensusInfo.status.oneofKind === 'activeBakerCommitteeInfo') {
        return {
            tag: 'activeBakerCommitteeInfo',
        };
    }
    else if (consensusInfo.status.oneofKind === 'activeFinalizerCommitteeInfo') {
        return {
            tag: 'activeFinalizerCommitteeInfo',
        };
    }
    else {
        throw Error('Error translating NodeInfoConsensusStatus: unexpected undefined');
    }
}
function trNetworkInfo(networkInfo) {
    return {
        nodeId: (0, util_1.unwrap)(networkInfo?.nodeId?.value),
        peerTotalSent: (0, util_1.unwrap)(networkInfo?.peerTotalSent),
        peerTotalReceived: (0, util_1.unwrap)(networkInfo?.peerTotalReceived),
        avgBpsIn: (0, util_1.unwrap)(networkInfo?.avgBpsIn),
        avgBpsOut: (0, util_1.unwrap)(networkInfo?.avgBpsOut),
    };
}
function trNodeInfo_Node(node) {
    const status = node.consensusStatus;
    switch (status.oneofKind) {
        case 'active':
            return {
                tag: 'active',
                bakerId: (0, util_1.unwrap)(status.active.bakerId?.value),
                status: trBakerConsensusInfoStatus(status.active),
            };
        case 'notRunning':
            return {
                tag: 'notRunning',
            };
        case 'passive':
            return {
                tag: 'passive',
            };
        case undefined:
            throw Error('Error translating nodeinfo: unexpected undefined');
    }
}
exports.trNodeInfo_Node = trNodeInfo_Node;
function nodeInfo(nodeInfo) {
    let details;
    if (nodeInfo.details.oneofKind === 'bootstrapper') {
        details = {
            tag: 'bootstrapper',
        };
    }
    else if (nodeInfo.details.oneofKind === 'node') {
        details = {
            tag: 'node',
            consensusStatus: trNodeInfo_Node(nodeInfo.details.node),
        };
    }
    else {
        throw Error('Invalid nodeinfo');
    }
    return {
        peerVersion: nodeInfo.peerVersion,
        localTime: (0, util_1.unwrap)(nodeInfo.localTime?.value),
        peerUptime: (0, util_1.unwrap)(nodeInfo.peerUptime?.value),
        networkInfo: trNetworkInfo(nodeInfo.networkInfo),
        details,
    };
}
exports.nodeInfo = nodeInfo;
function trCatchupStatus(catchupStatus) {
    const CatchupStatus = v2.PeersInfo_Peer_CatchupStatus;
    switch (catchupStatus) {
        case CatchupStatus.CATCHINGUP:
            return v1.NodeCatchupStatus.CatchingUp;
        case CatchupStatus.PENDING:
            return v1.NodeCatchupStatus.Pending;
        case CatchupStatus.UPTODATE:
            return v1.NodeCatchupStatus.UpToDate;
    }
}
function trPeerNetworkStats(networkStats) {
    return {
        packetsSent: (0, util_1.unwrap)(networkStats?.packetsSent),
        packetsReceived: (0, util_1.unwrap)(networkStats?.packetsReceived),
        latency: (0, util_1.unwrap)(networkStats?.latency),
    };
}
function peerInfo(peerInfo) {
    let consensusInfo;
    if (peerInfo.consensusInfo.oneofKind === 'bootstrapper') {
        consensusInfo = {
            tag: 'bootstrapper',
        };
    }
    else if (peerInfo.consensusInfo.oneofKind === 'nodeCatchupStatus') {
        consensusInfo = {
            tag: 'nodeCatchupStatus',
            catchupStatus: trCatchupStatus(peerInfo.consensusInfo.nodeCatchupStatus),
        };
    }
    else {
        throw Error('Error translating peerInfo: unexpected undefined');
    }
    return {
        peerId: (0, util_1.unwrap)(peerInfo.peerId?.value),
        ip: (0, util_1.unwrap)(peerInfo.socketAddress?.ip?.value),
        port: (0, util_1.unwrap)(peerInfo.socketAddress?.port?.value),
        networkStats: trPeerNetworkStats(peerInfo.networkStats),
        consensusInfo,
    };
}
exports.peerInfo = peerInfo;
function trAccountAmount(accountAmount) {
    return {
        account: unwrapToBase58(accountAmount.account),
        amount: (0, util_1.unwrap)(accountAmount.amount?.value),
    };
}
function blockSpecialEvent(specialEvent) {
    const event = specialEvent.event;
    switch (event.oneofKind) {
        case 'bakingRewards': {
            return {
                tag: 'bakingRewards',
                bakingRewards: (0, util_1.unwrap)(event.bakingRewards.bakerRewards).entries.map(trAccountAmount),
                remainder: (0, util_1.unwrap)(event.bakingRewards.remainder?.value),
            };
        }
        case 'mint': {
            return {
                tag: 'mint',
                mintBakingReward: (0, util_1.unwrap)(event.mint.mintBakingReward?.value),
                mintFinalizationReward: (0, util_1.unwrap)(event.mint.mintFinalizationReward?.value),
                mintPlatformDevelopmentCharge: (0, util_1.unwrap)(event.mint.mintPlatformDevelopmentCharge?.value),
                foundationAccount: unwrapToBase58(event.mint.foundationAccount),
            };
        }
        case 'finalizationRewards': {
            return {
                tag: 'finalizationRewards',
                finalizationRewards: event.finalizationRewards.finalizationRewards?.entries.map(trAccountAmount),
                remainder: (0, util_1.unwrap)(event.finalizationRewards.remainder?.value),
            };
        }
        case 'blockReward': {
            return {
                tag: 'blockReward',
                transactionFees: (0, util_1.unwrap)(event.blockReward.transactionFees?.value),
                oldGasAccount: (0, util_1.unwrap)(event.blockReward.oldGasAccount?.value),
                newGasAccount: (0, util_1.unwrap)(event.blockReward.newGasAccount?.value),
                bakerReward: (0, util_1.unwrap)(event.blockReward.bakerReward?.value),
                foundationCharge: (0, util_1.unwrap)(event.blockReward.foundationCharge?.value),
                baker: unwrapToBase58(event.blockReward.baker),
                foundationAccount: unwrapToBase58(event.blockReward.baker),
            };
        }
        case 'paydayFoundationReward': {
            return {
                tag: 'paydayFoundationReward',
                foundationAccount: unwrapToBase58(event.paydayFoundationReward.foundationAccount),
                developmentCharge: (0, util_1.unwrap)(event.paydayFoundationReward.developmentCharge?.value),
            };
        }
        case 'paydayAccountReward': {
            return {
                tag: 'paydayAccountReward',
                account: unwrapToBase58(event.paydayAccountReward.account),
                transactionFees: (0, util_1.unwrap)(event.paydayAccountReward.transactionFees?.value),
                bakerReward: (0, util_1.unwrap)(event.paydayAccountReward.bakerReward?.value),
                finalizationReward: (0, util_1.unwrap)(event.paydayAccountReward.finalizationReward?.value),
            };
        }
        case 'blockAccrueReward': {
            return {
                tag: 'blockAccrueReward',
                transactionFees: (0, util_1.unwrap)(event.blockAccrueReward.transactionFees?.value),
                oldGasAccount: (0, util_1.unwrap)(event.blockAccrueReward.oldGasAccount?.value),
                newGasAccount: (0, util_1.unwrap)(event.blockAccrueReward.newGasAccount?.value),
                bakerReward: (0, util_1.unwrap)(event.blockAccrueReward.bakerReward?.value),
                passiveReward: (0, util_1.unwrap)(event.blockAccrueReward.passiveReward?.value),
                foundationCharge: (0, util_1.unwrap)(event.blockAccrueReward.foundationCharge?.value),
                baker: (0, util_1.unwrap)(event.blockAccrueReward.baker?.value),
            };
        }
        case 'paydayPoolReward': {
            const poolOwner = event.paydayPoolReward.poolOwner?.value;
            return {
                tag: 'paydayPoolReward',
                transactionFees: (0, util_1.unwrap)(event.paydayPoolReward.transactionFees?.value),
                bakerReward: (0, util_1.unwrap)(event.paydayPoolReward.bakerReward?.value),
                finalizationReward: (0, util_1.unwrap)(event.paydayPoolReward.finalizationReward?.value),
                ...(poolOwner !== undefined && { poolOwner }),
            };
        }
        case undefined: {
            throw Error('Error translating BlockSpecialEvent: unexpected undefined');
        }
    }
}
exports.blockSpecialEvent = blockSpecialEvent;
function trFinalizationSummaryParty(party) {
    return {
        baker: (0, util_1.unwrap)(party.baker?.value),
        weight: party.weight,
        signed: party.signed,
    };
}
function trFinalizationSummary(summary) {
    return {
        block: unwrapValToHex(summary.block),
        index: (0, util_1.unwrap)(summary.index?.value),
        delay: (0, util_1.unwrap)(summary.delay?.value),
        finalizers: summary.finalizers.map(trFinalizationSummaryParty),
    };
}
function blockFinalizationSummary(finalizationSummary) {
    const summary = finalizationSummary.summary;
    if (summary.oneofKind === 'none') {
        return {
            tag: 'none',
        };
    }
    else if (summary.oneofKind === 'record') {
        return {
            tag: 'record',
            record: trFinalizationSummary(summary.record),
        };
    }
    else {
        throw Error('Error translating BlockFinalizationSummary: unexpected undefined');
    }
}
exports.blockFinalizationSummary = blockFinalizationSummary;
// ---------------------------- //
// --- V1 => V2 translation --- //
// ---------------------------- //
function accountTransactionSignatureToV2(signature) {
    function trSig(a) {
        return { value: buffer_1.Buffer.from(a, 'hex') };
    }
    function trCredSig(a) {
        return { signatures: (0, util_1.mapRecord)(a, trSig) };
    }
    return { signatures: (0, util_1.mapRecord)(signature, trCredSig) };
}
exports.accountTransactionSignatureToV2 = accountTransactionSignatureToV2;
function BlocksAtHeightRequestToV2(request) {
    if (typeof request === 'bigint') {
        return {
            blocksAtHeight: {
                oneofKind: 'absolute',
                absolute: { height: { value: request } },
            },
        };
    }
    else {
        return {
            blocksAtHeight: {
                oneofKind: 'relative',
                relative: {
                    genesisIndex: { value: request.genesisIndex },
                    height: { value: request.height },
                    restrict: request.restrict,
                },
            },
        };
    }
}
exports.BlocksAtHeightRequestToV2 = BlocksAtHeightRequestToV2;
